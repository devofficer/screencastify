import {
  addMetaData,
  addRecordingData,
  deleteRecordingDataById,
  updateMetaData,
} from '@castify/record-mv3/recording-indexed-db';
import { Instance, types, flow } from 'mobx-state-tree';
import { nanoid } from 'nanoid';
import { getHMSTimestampFromMS } from '../util/time-helpers';

const DEFAULT_MIME = 'video/webm; codecs="H264, opus"';
const AUDIO_BITRATE = 112000;
const BITRATE_PER_PIXEL = 20;
const RECORDER_TIMESLICE = 500;

export class NoMediaRecorder extends Error {
  constructor() {
    super('Attempted to start recording without a MediaRecorder');
  }
}

export class NoMediaStream extends Error {
  constructor() {
    super('Attempted to use mediastream but it does not exist');
  }
}

export class ReplacedMediaStream extends Error {
  constructor() {
    super('Attempted to replace mediaStream in a recording');
  }
}

export class StoppedInactiveRecording extends Error {
  constructor() {
    super('Attempted to stop recording that was inactive.');
  }
}

export class ResumedUnpausedRecording extends Error {
  constructor() {
    super("Attempted to resume recording that wasn't paused.");
  }
}

export class InvalidRecordingState extends Error {}

/**
 * Promisified setTimeout based sleep function.
 * @param seconds Time in seconds to sleep.
 */
const sleep = (seconds: number): Promise<void> =>
  new Promise((resolve) => {
    setTimeout(resolve, seconds * 800);
  });

export const Recording = types
  .model('Recording', {
    /** Autogenerated id for a single recording. */
    id: types.optional(types.identifier, nanoid),
    /** The state of a recording. */
    state: types.optional(
      types.union(
        types.literal('initialized'),
        types.literal('counting-in'),
        types.literal('recording'),
        types.literal('paused'),
        types.literal('stopped'),
        types.literal('error'),
        types.literal(undefined),
      ),
      'initialized',
    ),
    approximateDuration: types.optional(types.number, 0),
    readyForExport: types.optional(types.boolean, false),
    hasUploaded: types.optional(types.boolean, false),
    countInTimeRemaining: types.optional(types.number, 0),
  })
  .volatile((_self) => {
    return {
      /** Volatile state for the mediaStream being recorded. */
      _mediaStream: undefined as unknown as MediaStream | undefined,
      /** Volatile state holding the MediaRecorder for this recording. */
      _mediaRecorder: undefined as unknown as MediaRecorder | undefined,
      /** Volatile state holding the data chunks emitted during recording */
      dataChunks: [] as Blob[],
      /** Volatile state holding the concatenated data chunks emitted during recording */
      fullBlob: undefined as Blob | undefined,
      /** Volatile state holding a data url for the video after recording completes */
      dataURL: undefined as string | undefined,
      recorderError: undefined as Error | undefined,
      countInAbortController: new AbortController(),
      lastStartedAt: -1,
      lastLoggedTime: -1,
    };
  })
  .views((self) => {
    return {
      get mediaRecorder() {
        if (!self._mediaRecorder) {
          throw new NoMediaRecorder();
        }
        return self._mediaRecorder;
      },
      get mediaStream() {
        if (!self._mediaStream) {
          throw new NoMediaStream();
        }
        return self._mediaStream;
      },
    };
  })
  .views((self) => {
    return {
      /** Reader to pull the first videoTrack out of the mediaStream.
       * This assumes we're only recording one video track at a time.
       */
      get videoTrack() {
        return self.mediaStream.getVideoTracks()[0];
      },
      /**
       * Reader for the rectangular area of the video track being recorded.
       */
      get trackArea() {
        const { width, height } = this.videoTrack.getConstraints();
        const widthNumber = width as number;
        const hightNumber = height as number;
        return widthNumber * hightNumber;
      },
      /**
       * Reader for getting the appropriate video bitrate for a given video track size
       */
      get videoBitsPerSecond() {
        return this.trackArea * BITRATE_PER_PIXEL;
      },
      /**
       * Reader for getting the approriate audio bitrate
       */
      get audioBitsPerSecond() {
        return AUDIO_BITRATE;
      },
      /**
       * Reader for getting the mimeType to use for the recording
       */
      get mimeType() {
        return DEFAULT_MIME;
      },
      /**
       * Reader to sum the total bytes recorded to this point
       */
      get totalBytesRecorded() {
        return self.dataChunks.reduce((bytes, chunk) => bytes + chunk.size, 0);
      },
      /**
       * Reader to tell if the recorder can be paused
       * true implies the recording is active ("red light on")
       */
      get canPause() {
        return self.state === 'recording';
      },
      /**
       * Reader to tell if the recorder be resumed
       * true implies the recording is paused
       */
      get canResume() {
        return self.state === 'paused';
      },
      /**
       * Reader to tell if the recorder can be stopped
       * true implies the recording either paused or actively recording
       */
      get isRecordingInProgress() {
        return (
          self.state === 'counting-in' ||
          self.state === 'paused' ||
          self.state === 'recording'
        );
      },

      get formattedDuration() {
        return getHMSTimestampFromMS(self.approximateDuration);
      },

      /**
       * Reader to tell if the recording is counting-in to the start of recording.
       */
      get isCountingIn() {
        return self.state === 'counting-in';
      },
    };
  })
  .actions((self) => {
    return {
      /**
       * Reset recorder state to values sutiable to start a new recording.
       */
      async resetState(options: {
        resetMediaStreams: boolean; // or true.
        resetIndexedDbMetaData: boolean;
      }) {
        self.dataChunks = [];
        self.countInAbortController = new AbortController();
        self.countInTimeRemaining = 0;
        self.approximateDuration = 0;
        self.mediaRecorder.stop();
        self._mediaRecorder = undefined;
        if (options.resetMediaStreams) {
          this.stop();
          self._mediaStream = undefined;
        }
        this.setRecorderState('initialized');

        if (options.resetIndexedDbMetaData) {
          updateMetaData({
            recordingId: self.id,
            predictedDuration: 0,
            uploadStatus: 'not-started',
          });
        }
        //Remove all references to the recording data
        deleteRecordingDataById(self.id);
      },
      /**
       * Starts recording.
       *
       * Will through if not in a startable state.
       * Check `recording.canStart` before calling.
       */
      start() {
        /**
         * Setting countInTimeRemaining to zero and aborting the count in will
         *
         * Send a data update to the <CountInOverlay>, which will render `null` when time remaining is zero
         *
         * Aborting the count in controller will cease updates from the count in, JIC the count-in iteratior is
         * wildly out of sync with the start event.
         */
        self.lastStartedAt = Date.now();
        self.countInTimeRemaining = 0;
        self.countInAbortController.abort();
        self.mediaRecorder.start(RECORDER_TIMESLICE);
      },
      /**
       * Pauses a recording in progress.
       *
       * Will throw an error if not in a pausable state.
       * Check `recording.canPause` before calling.
       */
      pause() {
        if (self.mediaRecorder.state !== 'recording') {
          throw new Error(
            "Attempted to pause recording that wasn't recording.",
          );
        }
        self.mediaRecorder.pause();
      },
      /**
       * Resumes a paused recording.
       *
       * Will throw an error if not in a resumable state.
       * Check `recording.canResume` before calling.
       */
      resume() {
        if (!self.canResume) {
          throw new ResumedUnpausedRecording();
        }
        self.lastStartedAt = Date.now();
        self.mediaRecorder.resume();
      },
      /**
       * Stops a recording in progress.
       *
       * Will throw an error if not in a stoppable state.
       * Check `recording.canStop` before calling.
       */
      stop() {
        if (!self.isRecordingInProgress) {
          throw new StoppedInactiveRecording();
        }
        //force the recordings stop event to fire by stopping all active streams
        self.mediaStream.getTracks().forEach((track) => {
          track.stop();
        });
      },
      /**
       * Deletes a recording in progress
       */
      delete() {
        self.mediaRecorder.dispatchEvent(new Event('delete'));
      },

      restart() {
        //event resets the state of the recording and recreates the media recorder and event listeners
        self.mediaRecorder.dispatchEvent(new Event('restart'));
      },

      instantiateMediaRecorder() {
        self._mediaRecorder = new MediaRecorder(self.mediaStream, {
          mimeType: self.mimeType,
          // TODO: determine how to correctly determine optimal bitrates
          // audioBitsPerSecond: self.audioBitsPerSecond,
          // videoBitsPerSecond: self.videoBitsPerSecond
        });
      },
      /**
       * Creates a media recorder instance.
       *
       * A mediaStream MUST have been set with `recording.setMediaStream(stream)` FIRST.
       * Will throw an error if no mediaStream is available.
       */
      createMediaRecorder(
        onComplete: (blobData: Blob) => void,
        onDeleted: () => void,
      ) {
        this.instantiateMediaRecorder();

        const onError = () => {
          this.setRecorderState('error');
        };

        const onStart = () => {
          this.setRecorderState('recording');
        };

        const onPause = () => {
          this.setRecorderState('paused');
        };

        const onResume = () => {
          this.setRecorderState('recording');
        };

        const onStop = () => {
          this.setRecorderState('stopped');
        };

        const onDataAvailable = (event: BlobEvent) => {
          this.handleDataAvailable(event, onComplete);
        };

        function cleanupEventListeners() {
          self.mediaRecorder.removeEventListener(
            'dataavailable',
            onDataAvailable,
          );
          self.mediaRecorder.removeEventListener('error', onError);
          self.mediaRecorder.removeEventListener('start', onStart);
          self.mediaRecorder.removeEventListener('pause', onPause);
          self.mediaRecorder.removeEventListener('resume', onResume);
          self.mediaRecorder.removeEventListener('stop', onStop);
          self.mediaRecorder.removeEventListener('delete', handleDelete);
          self.mediaRecorder.removeEventListener('restart', handleRestart);
        }

        function addEventListeners() {
          self.mediaRecorder.addEventListener('dataavailable', onDataAvailable);
          self.mediaRecorder.addEventListener('error', onError);
          self.mediaRecorder.addEventListener('start', onStart);
          self.mediaRecorder.addEventListener('pause', onPause);
          self.mediaRecorder.addEventListener('resume', onResume);
          self.mediaRecorder.addEventListener('stop', onStop);
          self.mediaRecorder.addEventListener('delete', handleDelete, {
            once: true,
          });
          self.mediaRecorder.addEventListener('restart', handleRestart, {
            once: true,
          });
        }

        const handleDelete = async () => {
          cleanupEventListeners();
          await onDeleted();
          this.resetState({
            resetMediaStreams: true,
            resetIndexedDbMetaData: false,
          });
        };

        const handleRestart = () => {
          cleanupEventListeners();
          this.resetState({
            resetMediaStreams: false,
            resetIndexedDbMetaData: true,
          });
          this.instantiateMediaRecorder();
          addEventListeners();
        };
        //Add meta data to indexed db when we first create the media recorder
        addMetaData({
          recordingId: self.id,
          predictedDuration: 0,
          uploadStatus: 'not-started',
        });
        addEventListeners();
      },
      //error, recording, paused, recording, stopped
      setRecorderState(
        value:
          | 'initialized'
          | 'counting-in'
          | 'recording'
          | 'paused'
          | 'stopped'
          | 'error',
      ) {
        self.state = value;
      },

      /**
       * Handle new chunks of data coming off the MediaRecorder.
       *
       * When the last chunk is available, this creates a fullBlob and dataURL
       *
       * TODO: This leaves a copy of the dataChunks after, and that may result in a
       *        full copy of the video data.
       *
       * @param event Blob event passed in by MediaRecorder
       */
      handleDataAvailable(
        event: BlobEvent,
        onComplete: (blobData: Blob) => void,
      ) {
        self.dataChunks = [...self.dataChunks, event.data];
        //Update meta data entry everytime we get a new chunk
        updateMetaData({
          recordingId: self.id,
          predictedDuration: self.approximateDuration,
          uploadStatus: 'not-started',
        });
        //Everytime this event emits add the recording data to db
        addRecordingData({
          segmentId: self.dataChunks.length - 1,
          recordingId: self.id,
          data: event.data,
        });
        if (self.mediaRecorder.state === 'inactive') {
          // if (self.fullBlob && self.dataURL) {
          //   URL.revokeObjectURL(self.dataURL);
          // }
          self.fullBlob = new Blob(self.dataChunks, {
            type: self.mimeType,
          });

          this.setReadyForExport(true);
          //Update meta data once we are ready to start an upload
          updateMetaData({
            recordingId: self.id,
            predictedDuration: self.approximateDuration,
            uploadStatus: 'in-progress',
          });

          onComplete(self.fullBlob);
        }

        // setting approximate duration by checking time against the
        // later of the last time this callback was run, or the last time
        // the video was started/resumed.
        const lastMark = Math.max(self.lastStartedAt, self.lastLoggedTime);
        const now = Date.now();
        self.approximateDuration += now - lastMark;
        self.lastLoggedTime = now;
        // end approximateDuration check
      },
      /**
       * Setter for mediaStream, will throw an error if mediaStream has already been set.
       */
      setMediaStream(mediaStream: MediaStream) {
        if (self._mediaStream) {
          throw new ReplacedMediaStream();
        }
        self._mediaStream = mediaStream;
      },
      setReadyForExport(isReady: boolean) {
        self.readyForExport = isReady;
      },
      setHasUploaded(uploaded: boolean) {
        self.hasUploaded = uploaded;
      },
      /**
       * Setter for the time remaining in the count-in timer.
       */
      setCountInTimeRemaining(timeRemaining: number) {
        self.countInTimeRemaining = timeRemaining;
      },
    };
  })
  .actions((self) => {
    return {
      /**
       * Runs a count-in for a recording
       */
      countIn: flow(function* (duration: number) {
        self.setRecorderState('counting-in');

        for (let timeRemaining = duration; timeRemaining > 0; timeRemaining--) {
          self.countInTimeRemaining = timeRemaining;
          yield sleep(1);
          if (self.countInAbortController.signal.aborted === true) {
            self.countInTimeRemaining = 0;
            break;
          }
        }
      }),
    };
  });

export type IRecording = Instance<typeof Recording>;
